    <script>
      // ============================================================
      //  Configuration & Small Utilities
      // ============================================================

      const WORKER_BASE =
        "https://super-mountain-9f8d.apgarns.workers.dev";

      const qs = (selector, root = document) => root.querySelector(selector);

      const fmtDate = (d) => new Date(d).toISOString().slice(0, 10);

      const addDays = (date, n) => {
        const z = new Date(date);
        z.setDate(z.getDate() + n);
        return z;
      };

      const showToast = (msg) => {
        const el = qs("#toast");
        el.textContent = msg;
        el.classList.add("show");
        setTimeout(() => el.classList.remove("show"), 2600);
      };

      // App state now includes urgencyEnabled
      let STATE = {
        items: [],
        filters: { course: "", type: "" },
        urgencyEnabled: true,
      };

      // ============================================================
      //  Urgency Helper
      // ============================================================

      function getUrgencyClass(dueStr) {
        if (!dueStr) return "";
        const today = new Date();
        const endOfDay = new Date(dueStr + "T23:59:59");
        const diffMs = endOfDay - today;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

        if (isNaN(diffDays)) return "";
        if (diffDays < 0) return "danger"; // overdue
        if (diffDays <= 2) return "warn";  // due very soon
        return "ok";                       // later
      }

      // ============================================================
      //  Rendering & Filter Hydration
      // ============================================================

      function render() {
        const list = qs("#list");
        list.innerHTML = "";

        const { course, type } = STATE.filters;

        const filtered = STATE.items.filter(
          (x) =>
            (!course || x.course === course) && (!type || x.type === type)
        );

        filtered.sort((a, b) => {
          const da = a.due || "";
          const db = b.due || "";
          if (da < db) return -1;
          if (da > db) return 1;
          return 0;
        });

        for (const x of filtered) {
          const li = document.createElement("li");
          li.className = "item";

          const left = document.createElement("div");
          const title = document.createElement("div");
          title.className = "title";

          // If we have a Canvas URL, make the title clickable
          if (x.url) {
            const a = document.createElement("a");
            a.href = x.url;
            a.target = "_blank";
            a.rel = "noopener noreferrer";
            a.textContent = x.title;
            a.style.textDecoration = "none";
            a.style.color = "inherit";
            title.appendChild(a);
          } else {
            title.textContent = x.title;
          }

          const meta = document.createElement("div");
          meta.className = "meta";

          const parts = [];
          let urgencyClass = "";

          if (STATE.urgencyEnabled && x.due) {
            urgencyClass = getUrgencyClass(x.due);
          }

          if (x.due) {
            if (urgencyClass) {
              parts.push(
                `Due <span class="${urgencyClass}">${x.due}</span>`
              );
            } else {
              parts.push("Due " + x.due);
            }
          }
          if (x.course) parts.push(x.course);
          if (x.origin) parts.push("from " + x.origin);

          meta.innerHTML = parts.join(" â€¢ ");

          left.append(title, meta);

          const right = document.createElement("div");
          const chip = document.createElement("span");
          chip.className = "type " + x.type;
          chip.textContent = x.type;
          right.appendChild(chip);

          li.append(left, right);
          list.appendChild(li);
        }

        hydrateFilters();
      }

      function hydrateFilters() {
        const sel = qs("#filterCourse");
        const previousValue = sel.value;

        const courses = Array.from(
          new Set(STATE.items.map((x) => x.course).filter(Boolean))
        ).sort();

        sel.innerHTML =
          '<option value="">All</option>' +
          courses
            .map(
              (c) =>
                `<option ${c === previousValue ? "selected" : ""}>${c}</option>`
            )
            .join("");
      }

      // ============================================================
      //  Canvas Worker-backed Fetch Helpers
      // ============================================================

      async function canvasFetch(
        path,
        { method = "GET", params = null, body = null } = {}
      ) {
        const url = new URL(WORKER_BASE + "/proxy");
        url.searchParams.set("path", path);

        if (params) {
          Object.entries(params).forEach(([key, value]) =>
            url.searchParams.set(key, value)
          );
        }

        const init = {
          method,
          headers: {},
        };

        if (body) {
          init.headers["content-type"] = "application/json";
          init.body = JSON.stringify(body);
        }

        const res = await fetch(url.toString(), init);

        if (!res.ok) {
          const text = await res.text().catch(() => "");
          throw new Error(`Worker ${res.status}: ${text || res.statusText}`);
        }

        const link = res.headers.get("x-pagination-link");
        const data = await res.json();

        return { data, link };
      }

      function parseNext(link) {
        if (!link) return null;

        const parts = link.split(",").map((x) => x.trim());

        for (const p of parts) {
          const match = p.match(/<([^>]+)>; rel="next"/);
          if (match) return match[1];
        }

        return null;
      }

      async function fetchAll(urlOrPath) {
        const out = [];
        let path = urlOrPath;

        while (path) {
          const isAbsolute = path.startsWith("http");
          const rel = isAbsolute
            ? new URL(path).pathname + new URL(path).search
            : path;

          const { data, link } = await canvasFetch(rel);
          out.push(...data);

          const next = parseNext(link);
          path = next;
        }

        return out;
      }

      // ============================================================
      //  Canvas Planner Pull & Task Mapping
      // ============================================================

      async function pullPlanner(startISO, endISO) {
        const params = {
          start_date: startISO,
          end_date: endISO,
          per_page: 50,
        };

        const first = await canvasFetch("/api/v1/planner/items", { params });
        let items = first.data;

        let next = parseNext(first.link);
        while (next) {
          const chunk = await fetchAll(next);
          items = items.concat(chunk);
          next = null;
        }

        return items.map((it) => {
          const t = it.plannable_type?.toLowerCase();
          const due =
            it.plannable?.due_at ||
            it.plannable?.todo_date ||
            it.plannable?.start_at ||
            it.plannable?.end_at ||
            null;

          let type = "event";
          if (
            t === "assignment" ||
            t === "quiz" ||
            t === "discussion_topic"
          ) {
            type = "assignment";
          }
          if (t === "planner_note") {
            type = "note";
          }

          // Try to extract a usable Canvas URL
          const url =
            it.html_url ||
            it.plannable?.html_url ||
            it.plannable?.url ||
            "";

          return {
            title: it.plannable?.title || it.title || "(untitled)",
            due: due ? due.slice(0, 10) : "",
            course:
              it.context_name ||
              (it.course ? it.course.name : "") ||
              "",
            type,
            origin: "Canvas",
            url,
          };
        });
      }

      // ============================================================
      //  Push Local Tasks to Canvas (Notes & Events)
      // ============================================================

      async function pushTaskToCanvas({ title, due, details, type }) {
        if (type === "note") {
          const body = {
            title,
            details,
            todo_date: due,
          };

          await canvasFetch("/api/v1/planner_notes", {
            method: "POST",
            body,
          });

          return "Planner note created in Canvas";
        } else {
          const startAt = new Date(due + "T12:00:00");
          const endAt = new Date(startAt.getTime() + 60 * 60 * 1000);

          const body = {
            calendar_event: {
              context_code: "user_self",
              title,
              start_at: startAt.toISOString(),
              end_at: endAt.toISOString(),
              description: details || "",
            },
          };

          await canvasFetch("/api/v1/calendar_events", {
            method: "POST",
            body,
          });

          return "Personal calendar event created in Canvas";
        }
      }

      // ============================================================
      //  Event Wiring: Form, Filters, Sync, Dark Mode, Urgency Toggle
      // ============================================================

      qs("#taskForm").addEventListener("submit", async (e) => {
        e.preventDefault();

        const title = qs("#title").value.trim();
        const due = qs("#due").value;
        const course = qs("#course").value.trim();
        const details = qs("#details").value.trim();
        const type = qs("#type").value;

        if (!title || !due) return;

        const item = {
          title,
          due,
          course,
          type,
          origin: "Local",
          url: "", // local tasks have no Canvas page
        };

        STATE.items.unshift(item);
        render();

        if (qs("#pushToCanvas").checked) {
          try {
            const msg = await pushTaskToCanvas({
              title,
              due,
              details,
              type,
            });
            showToast("Synced: " + msg);
          } catch (err) {
            console.error(err);
            showToast("Could not sync to Canvas: " + err.message);
          }
        } else {
          showToast("Task added locally");
        }

        e.target.reset();
        qs("#title").focus();
      });

      qs("#filterCourse").addEventListener("change", (e) => {
        STATE.filters.course = e.target.value;
        render();
      });

      qs("#filterType").addEventListener("change", (e) => {
        STATE.filters.type = e.target.value;
        render();
      });

      qs("#clearFilters").addEventListener("click", () => {
        STATE.filters = { course: "", type: "" };
        render();
      });

      // New: toggle urgency highlighting
      qs("#urgencyToggle").addEventListener("change", (e) => {
        STATE.urgencyEnabled = e.target.checked;
        render();
      });

      qs("#darkToggle").addEventListener("click", () => {
        document.body.classList.toggle("dark");
      });

      qs("#syncFrom").addEventListener("click", async () => {
        try {
          const start = new Date();
          const end = addDays(start, 14);
          const pulled = await pullPlanner(
            start.toISOString(),
            end.toISOString()
          );

          STATE.items = mergeItems(STATE.items, pulled);
          showToast("Pulled " + pulled.length + " items from Canvas");
          render();
        } catch (err) {
          console.error(err);
          showToast("Sync failed: " + err.message);
        }
      });

      qs("#syncWindow").addEventListener("click", async () => {
        try {
          const start = new Date();
          const end = addDays(start, 30);
          const pulled = await pullPlanner(
            start.toISOString(),
            end.toISOString()
          );

          STATE.items = mergeItems(STATE.items, pulled);
          showToast("Pulled next 30 days from Canvas");
          render();
        } catch (err) {
          console.error(err);
          showToast("Sync failed: " + err.message);
        }
      });

      function mergeItems(local, incoming) {
        const key = (x) =>
          [x.title, x.due, x.course, x.type].join("|").toLowerCase();

        const seen = new Set(local.map(key));
        const merged = local.slice();

        for (const it of incoming) {
          if (!seen.has(key(it))) {
            merged.push(it);
          }
        }

        return merged;
      }

      // ============================================================
      //  Initialization
      // ============================================================

      if (typeof seedDemo === "function") {
        seedDemo();
      }

      render();
    </script>
